scalar Date
scalar BigInt

type BattlePass {
  name: String!
  description: String!
  price: String!
  currency: String!
  endDate: Date!
  seasonId: BigInt!
  maxLevel: BigInt!
  levelInfo: [LevelInfo]!
  userInfo: BattlePassUser
}

type LevelInfo {
  level: Int!
  xpToCompleteLevel: BigInt!
  freeReward: Reward
  premiumReward: Reward
}

type BattlePassUser {
  xp: BigInt!
  level: BigInt!
  unclaimedFreeRewards: [Int]!
  premium: PremiumBattlePassUser
}

type PremiumBattlePassUser {
  owned: BigInt!
  unclaimedPremiumRewards: [Int]!
}

type Reward {
  id: BigInt
  qty: BigInt!
  metadata: RewardMetadata
  rewardType: RewardType
  creatorId: Int!
}

# do not change order
enum RewardType {
  PREMIUM_PASS
  CREATOR_TOKEN
  LOOTBOX
  REDEEMABLE
  SPECIAL
}

type RewardMetadata {
  name: String!
  description: String!
  image: String!
}

type Recipe {
  recipeId: BigInt!
  isActive: Boolean!
  inputIngredients: [Reward]!
  outputIngredients: [Reward]!
}

# handle each reward type separately
type Inventory {
  #PREMIUM_PASS,SPECIAL, CREATOR_TOKEN, UNREDEEMED REDEEMABLE, LOOTBOX just check balance
  default: [Reward]!
  redeemed: [Redeemed]!
}

#group by same id in same contract since user can redeem multiple of same id
type Redeemed {
  reward: Reward!
  status: [RedeemStatus]!
}

enum RedeemStatus {
  REDEEMED
  PROCESSING
  REJECTED
}

type LootboxOption {
  probability: Int!
  reward: [Reward]!
}

type Query {
  getBattlePass(creatorId: Int!): BattlePass
  getInventory: Inventory
  getLootboxOptions(creatorId: Int!, lootboxId: Int!): [LootboxOption]
  getRecipes(creatorId: Int!): [Recipe]
  getRecipe(creatorId: Int!, recipeId: Int!): Recipe
}

type Mutation {
  claimReward(
    creatorId: Int!
    level: Int!
    premium: Boolean!
    autoRedeem: Boolean!
  ): ClaimRewardResponse!
  redeemReward(creatorId: Int!, itemId: Int!): MutationResponse!
  craft(recipeId: Int!): MutationResponse!
}

type ClaimRewardResponse {
  success: Boolean!
  reward: [Reward]
  description: String
  missingFields: UserMissingFields
}

type UserMissingFields {
  payment: [RequiredUserPaymentOptions]
  social: [RequiredUserSocialOptions]
}

enum RequiredUserSocialOptions {
  INSTAGRAM_USERNAME
  TWITTER_USERNAME
  TWITCH_USERNAME
  CLASH_USERNAME
  PREFERRED_SOCIAL
}

enum RequiredUserPaymentOptions {
  CASHAPP
  PAYPAL_EMAIL
  VENMO_USERNAME
}

type MutationResponse {
  success: Boolean!
  description: String
}
