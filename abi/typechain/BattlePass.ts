/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type LootboxOptionStruct = {
  rarityRange: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
  ids: PromiseOrValue<BigNumberish>[];
  qtys: PromiseOrValue<BigNumberish>[];
};

export type LootboxOptionStructOutput = [
  [BigNumber, BigNumber],
  BigNumber[],
  BigNumber[]
] & {
  rarityRange: [BigNumber, BigNumber];
  ids: BigNumber[];
  qtys: BigNumber[];
};

export type LevelInfoStruct = {
  xpToCompleteLevel: PromiseOrValue<BigNumberish>;
  freeRewardId: PromiseOrValue<BigNumberish>;
  freeRewardQty: PromiseOrValue<BigNumberish>;
  premiumRewardId: PromiseOrValue<BigNumberish>;
  premiumRewardQty: PromiseOrValue<BigNumberish>;
};

export type LevelInfoStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  xpToCompleteLevel: BigNumber;
  freeRewardId: BigNumber;
  freeRewardQty: BigNumber;
  premiumRewardId: BigNumber;
  premiumRewardQty: BigNumber;
};

export interface BattlePassInterface extends utils.Interface {
  functions: {
    "CREATOR_TOKEN_ID()": FunctionFragment;
    "INVALID_STARTING_ID()": FunctionFragment;
    "LOOTBOX_STARTING_ID()": FunctionFragment;
    "PREMIUM_PASS_STARTING_ID()": FunctionFragment;
    "REDEEMABLE_STARTING_ID()": FunctionFragment;
    "SPECIAL_STARTING_ID()": FunctionFragment;
    "addReward(uint256,uint256,bool,uint256,uint256)": FunctionFragment;
    "balanceOf(address,uint256)": FunctionFragment;
    "balanceOfBatch(address[],uint256[])": FunctionFragment;
    "burn(address,uint256,uint256)": FunctionFragment;
    "calculateRandom(uint256)": FunctionFragment;
    "checkType(uint256)": FunctionFragment;
    "claimReward(uint256,uint256,bool)": FunctionFragment;
    "crafting()": FunctionFragment;
    "creatorId()": FunctionFragment;
    "delegate(address,uint256)": FunctionFragment;
    "delegatedBy(address,address)": FunctionFragment;
    "delegatedTotal(address)": FunctionFragment;
    "getLootboxOptionByIdx(uint256,uint256)": FunctionFragment;
    "getLootboxOptionsLength(uint256)": FunctionFragment;
    "getMaxLevel(uint256)": FunctionFragment;
    "giveXp(uint256,uint256,address)": FunctionFragment;
    "isApprovedForAll(address,address)": FunctionFragment;
    "isRewardClaimed(address,uint256,uint256,bool)": FunctionFragment;
    "isTrustedForwarder(address)": FunctionFragment;
    "isUserPremium(address,uint256)": FunctionFragment;
    "level(address,uint256)": FunctionFragment;
    "lootboxId()": FunctionFragment;
    "mint(address,uint256,uint256)": FunctionFragment;
    "newLootbox((uint256[2],uint256[],uint256[])[])": FunctionFragment;
    "newSeason((uint256,uint256,uint256,uint256,uint256)[])": FunctionFragment;
    "openLootbox(uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "safeTransferFrom(address,address,uint256,uint256,bytes)": FunctionFragment;
    "seasonId()": FunctionFragment;
    "seasonInfo(uint256,uint256)": FunctionFragment;
    "setApprovalForAll(address,bool)": FunctionFragment;
    "setCrafting(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "setURI(string)": FunctionFragment;
    "setXp(uint256,uint256,uint256)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "tokenURI()": FunctionFragment;
    "undelegate(address,uint256)": FunctionFragment;
    "uri(uint256)": FunctionFragment;
    "userInfo(address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "CREATOR_TOKEN_ID"
      | "INVALID_STARTING_ID"
      | "LOOTBOX_STARTING_ID"
      | "PREMIUM_PASS_STARTING_ID"
      | "REDEEMABLE_STARTING_ID"
      | "SPECIAL_STARTING_ID"
      | "addReward"
      | "balanceOf"
      | "balanceOfBatch"
      | "burn"
      | "calculateRandom"
      | "checkType"
      | "claimReward"
      | "crafting"
      | "creatorId"
      | "delegate"
      | "delegatedBy"
      | "delegatedTotal"
      | "getLootboxOptionByIdx"
      | "getLootboxOptionsLength"
      | "getMaxLevel"
      | "giveXp"
      | "isApprovedForAll"
      | "isRewardClaimed"
      | "isTrustedForwarder"
      | "isUserPremium"
      | "level"
      | "lootboxId"
      | "mint"
      | "newLootbox"
      | "newSeason"
      | "openLootbox"
      | "owner"
      | "safeBatchTransferFrom"
      | "safeTransferFrom"
      | "seasonId"
      | "seasonInfo"
      | "setApprovalForAll"
      | "setCrafting"
      | "setOwner"
      | "setURI"
      | "setXp"
      | "supportsInterface"
      | "tokenURI"
      | "undelegate"
      | "uri"
      | "userInfo"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "CREATOR_TOKEN_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "INVALID_STARTING_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LOOTBOX_STARTING_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PREMIUM_PASS_STARTING_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "REDEEMABLE_STARTING_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "SPECIAL_STARTING_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addReward",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burn",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRandom",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "checkType",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimReward",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(functionFragment: "crafting", values?: undefined): string;
  encodeFunctionData(functionFragment: "creatorId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "delegate",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegatedBy",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "delegatedTotal",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLootboxOptionByIdx",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLootboxOptionsLength",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxLevel",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "giveXp",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isRewardClaimed",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isTrustedForwarder",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isUserPremium",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "level",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "lootboxId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newLootbox",
    values: [LootboxOptionStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "newSeason",
    values: [LevelInfoStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "openLootbox",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "safeBatchTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "seasonId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "seasonInfo",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCrafting",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setURI",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setXp",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "tokenURI", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "undelegate",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "uri",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "userInfo",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "CREATOR_TOKEN_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "INVALID_STARTING_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LOOTBOX_STARTING_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PREMIUM_PASS_STARTING_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "REDEEMABLE_STARTING_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "SPECIAL_STARTING_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addReward", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateRandom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "checkType", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "crafting", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "creatorId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "delegate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "delegatedBy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delegatedTotal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLootboxOptionByIdx",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLootboxOptionsLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxLevel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "giveXp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRewardClaimed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTrustedForwarder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUserPremium",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "level", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lootboxId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "newLootbox", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "newSeason", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "openLootbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "safeBatchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "seasonId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "seasonInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCrafting",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setURI", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setXp", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "undelegate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "uri", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "userInfo", data: BytesLike): Result;

  events: {
    "ApprovalForAll(address,address,bool)": EventFragment;
    "Delegated(address,address,uint256)": EventFragment;
    "LootboxOpened(uint256,uint256,address)": EventFragment;
    "OwnerUpdated(address,address)": EventFragment;
    "TransferBatch(address,address,address,uint256[],uint256[])": EventFragment;
    "TransferSingle(address,address,address,uint256,uint256)": EventFragment;
    "URI(string,uint256)": EventFragment;
    "Undelegated(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Delegated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LootboxOpened"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferBatch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferSingle"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "URI"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Undelegated"): EventFragment;
}

export interface ApprovalForAllEventObject {
  owner: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  ApprovalForAllEventObject
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface DelegatedEventObject {
  delegator: string;
  delegatee: string;
  amount: BigNumber;
}
export type DelegatedEvent = TypedEvent<
  [string, string, BigNumber],
  DelegatedEventObject
>;

export type DelegatedEventFilter = TypedEventFilter<DelegatedEvent>;

export interface LootboxOpenedEventObject {
  lootboxId: BigNumber;
  idxOpened: BigNumber;
  user: string;
}
export type LootboxOpenedEvent = TypedEvent<
  [BigNumber, BigNumber, string],
  LootboxOpenedEventObject
>;

export type LootboxOpenedEventFilter = TypedEventFilter<LootboxOpenedEvent>;

export interface OwnerUpdatedEventObject {
  user: string;
  newOwner: string;
}
export type OwnerUpdatedEvent = TypedEvent<
  [string, string],
  OwnerUpdatedEventObject
>;

export type OwnerUpdatedEventFilter = TypedEventFilter<OwnerUpdatedEvent>;

export interface TransferBatchEventObject {
  operator: string;
  from: string;
  to: string;
  ids: BigNumber[];
  amounts: BigNumber[];
}
export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  TransferBatchEventObject
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export interface TransferSingleEventObject {
  operator: string;
  from: string;
  to: string;
  id: BigNumber;
  amount: BigNumber;
}
export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  TransferSingleEventObject
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export interface URIEventObject {
  value: string;
  id: BigNumber;
}
export type URIEvent = TypedEvent<[string, BigNumber], URIEventObject>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export interface UndelegatedEventObject {
  delegator: string;
  delegatee: string;
  amount: BigNumber;
}
export type UndelegatedEvent = TypedEvent<
  [string, string, BigNumber],
  UndelegatedEventObject
>;

export type UndelegatedEventFilter = TypedEventFilter<UndelegatedEvent>;

export interface BattlePass extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: BattlePassInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CREATOR_TOKEN_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    INVALID_STARTING_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    LOOTBOX_STARTING_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    PREMIUM_PASS_STARTING_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    REDEEMABLE_STARTING_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    SPECIAL_STARTING_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * only owner can set rewards
     * sets a reward for a seasonId and at level
     * @param _level level at which to change the reward
     * @param _seasonId seasonId for which to change the reward
     * @param id new reward id
     * @param premium true when setting a premium reward
     * @param qty new reward qty
     */
    addReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      qty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceOfBatch(
      owners: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { balances: BigNumber[] }>;

    /**
     * allows the owner/crafting contract to burn tokens
     * @param amount burn amount
     * @param id burn id
     * @param to burn from address
     */
    burn(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * calculates a pseudorandom index between 0-99
     */
    calculateRandom(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * checks a reward type by id; will revert for 0
     */
    checkType(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    /**
     * reverts when: user claims a reward for a level at which they are NOT user claims an already claimed reward user claims a premium reward, but is NOT eligible for it when a user has a premium pass and it is their first time claiming a premium reward then burn 1 pass from their balance and set claimedPremiumPass to be true a user can own multiple premium passes just like any other reward it will NOT be burned if the user has already claimed a premium reward
     * claims a reward for a seasonId and at level
     * @param _level level at which to claim the reward
     * @param _seasonId seasonId for which to claim the reward
     * @param premium true when claiming a premium reward
     */
    claimReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    crafting(overrides?: CallOverrides): Promise<[string]>;

    creatorId(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * revert if balance is insufficient
     * delegates msg.sender's tokens to a delegatee
     * @param amount the amount of tokens to delegate
     * @param delegatee the address receiving the delegated tokens
     */
    delegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * tracks who delegates to whom and how much
     */
    delegatedBy(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    delegatedTotal(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * gets a lootboxOption by lootboxId and index
     */
    getLootboxOptionByIdx(
      id: PromiseOrValue<BigNumberish>,
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [LootboxOptionStructOutput] & { option: LootboxOptionStructOutput }
    >;

    /**
     * gets a lootboxOptions length by lootboxId
     */
    getLootboxOptionsLength(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * max level is reached when xpToCompleteLevel == 0
     * gets the max level for a seasonId
     */
    getMaxLevel(
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { maxLevel: BigNumber }>;

    /**
     * only owner can give xp
     * gives xp to a user upon completion of quests
     * @param _seasonId seasonId for which to give xp
     * @param user user to give xp to
     * @param xp amount of xp to give
     */
    giveXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * checks a user claim status on a reward for a seasonId and at level
     * @param _level level at which to check
     * @param _seasonId seasonId for which to check
     * @param premium true when checking for premium rewards
     * @param user user address for which to check
     */
    isRewardClaimed(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTrustedForwarder(
      forwarder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * user is considered premium when:     they own one premium pass or     they have already claimed a premium reward
     * checks if a user has premium pass
     * @param _seasonId seasonId for which to check for premium pass
     * @param user user address
     */
    isUserPremium(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * breaks at the last level, where xpToCompleteLevel is 0
     * gets user level for a seasonId
     * @param _seasonId seasonId for which to get level
     * @param user user address for which to get level
     */
    level(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { userLevel: BigNumber }>;

    lootboxId(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * allows the owner/crafting contract to mint tokens
     * @param amount mint amount
     * @param id mint id
     * @param to mint to address
     */
    mint(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    newLootbox(
      options: LootboxOptionStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    newSeason(
      levelInfo: LevelInfoStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * upto user to not send a bad id here.
     * opens a lootbox
     * @param id lootboxId to open
     */
    openLootbox(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    seasonId(overrides?: CallOverrides): Promise<[BigNumber]>;

    seasonInfo(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        xpToCompleteLevel: BigNumber;
        freeRewardId: BigNumber;
        freeRewardQty: BigNumber;
        premiumRewardId: BigNumber;
        premiumRewardQty: BigNumber;
      }
    >;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * only owner can set it
     * sets the crafting proxy address
     * @param _crafting new address
     */
    setCrafting(
      _crafting: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * only owner can set it
     * sets the uri
     * @param _uri new string with the format https://<>/creatorId/id.json
     */
    setURI(
      _uri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * sets required xp to levelup
     * @param _level level at which to change xp
     * @param _seasonId seasonId for which to change xp
     * @param xp new xp required to levelup
     */
    setXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    tokenURI(overrides?: CallOverrides): Promise<[string]>;

    /**
     * revert if msg.sender tries to undelegate more tokens than they delegated
     * undelegates the tokens from a delegatee
     * @param amount the amount of tokens to undelegate
     * @param delegatee the address who recevied the delegated tokens
     */
    undelegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * returns uri by id
     */
    uri(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { xp: BigNumber; claimedPremiumPass: boolean }
    >;
  };

  CREATOR_TOKEN_ID(overrides?: CallOverrides): Promise<BigNumber>;

  INVALID_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

  LOOTBOX_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

  PREMIUM_PASS_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

  REDEEMABLE_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

  SPECIAL_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * only owner can set rewards
   * sets a reward for a seasonId and at level
   * @param _level level at which to change the reward
   * @param _seasonId seasonId for which to change the reward
   * @param id new reward id
   * @param premium true when setting a premium reward
   * @param qty new reward qty
   */
  addReward(
    _seasonId: PromiseOrValue<BigNumberish>,
    _level: PromiseOrValue<BigNumberish>,
    premium: PromiseOrValue<boolean>,
    id: PromiseOrValue<BigNumberish>,
    qty: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  balanceOf(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceOfBatch(
    owners: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * allows the owner/crafting contract to burn tokens
   * @param amount burn amount
   * @param id burn id
   * @param to burn from address
   */
  burn(
    to: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * calculates a pseudorandom index between 0-99
   */
  calculateRandom(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * checks a reward type by id; will revert for 0
   */
  checkType(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * reverts when: user claims a reward for a level at which they are NOT user claims an already claimed reward user claims a premium reward, but is NOT eligible for it when a user has a premium pass and it is their first time claiming a premium reward then burn 1 pass from their balance and set claimedPremiumPass to be true a user can own multiple premium passes just like any other reward it will NOT be burned if the user has already claimed a premium reward
   * claims a reward for a seasonId and at level
   * @param _level level at which to claim the reward
   * @param _seasonId seasonId for which to claim the reward
   * @param premium true when claiming a premium reward
   */
  claimReward(
    _seasonId: PromiseOrValue<BigNumberish>,
    _level: PromiseOrValue<BigNumberish>,
    premium: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  crafting(overrides?: CallOverrides): Promise<string>;

  creatorId(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * revert if balance is insufficient
   * delegates msg.sender's tokens to a delegatee
   * @param amount the amount of tokens to delegate
   * @param delegatee the address receiving the delegated tokens
   */
  delegate(
    delegatee: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * tracks who delegates to whom and how much
   */
  delegatedBy(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  delegatedTotal(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets a lootboxOption by lootboxId and index
   */
  getLootboxOptionByIdx(
    id: PromiseOrValue<BigNumberish>,
    idx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<LootboxOptionStructOutput>;

  /**
   * gets a lootboxOptions length by lootboxId
   */
  getLootboxOptionsLength(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * max level is reached when xpToCompleteLevel == 0
   * gets the max level for a seasonId
   */
  getMaxLevel(
    _seasonId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * only owner can give xp
   * gives xp to a user upon completion of quests
   * @param _seasonId seasonId for which to give xp
   * @param user user to give xp to
   * @param xp amount of xp to give
   */
  giveXp(
    _seasonId: PromiseOrValue<BigNumberish>,
    xp: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * checks a user claim status on a reward for a seasonId and at level
   * @param _level level at which to check
   * @param _seasonId seasonId for which to check
   * @param premium true when checking for premium rewards
   * @param user user address for which to check
   */
  isRewardClaimed(
    user: PromiseOrValue<string>,
    _seasonId: PromiseOrValue<BigNumberish>,
    _level: PromiseOrValue<BigNumberish>,
    premium: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTrustedForwarder(
    forwarder: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * user is considered premium when:     they own one premium pass or     they have already claimed a premium reward
   * checks if a user has premium pass
   * @param _seasonId seasonId for which to check for premium pass
   * @param user user address
   */
  isUserPremium(
    user: PromiseOrValue<string>,
    _seasonId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * breaks at the last level, where xpToCompleteLevel is 0
   * gets user level for a seasonId
   * @param _seasonId seasonId for which to get level
   * @param user user address for which to get level
   */
  level(
    user: PromiseOrValue<string>,
    _seasonId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  lootboxId(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * allows the owner/crafting contract to mint tokens
   * @param amount mint amount
   * @param id mint id
   * @param to mint to address
   */
  mint(
    to: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  newLootbox(
    options: LootboxOptionStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  newSeason(
    levelInfo: LevelInfoStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * upto user to not send a bad id here.
   * opens a lootbox
   * @param id lootboxId to open
   */
  openLootbox(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  safeBatchTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  safeTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  seasonId(overrides?: CallOverrides): Promise<BigNumber>;

  seasonInfo(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      xpToCompleteLevel: BigNumber;
      freeRewardId: BigNumber;
      freeRewardQty: BigNumber;
      premiumRewardId: BigNumber;
      premiumRewardQty: BigNumber;
    }
  >;

  setApprovalForAll(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * only owner can set it
   * sets the crafting proxy address
   * @param _crafting new address
   */
  setCrafting(
    _crafting: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * only owner can set it
   * sets the uri
   * @param _uri new string with the format https://<>/creatorId/id.json
   */
  setURI(
    _uri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * sets required xp to levelup
   * @param _level level at which to change xp
   * @param _seasonId seasonId for which to change xp
   * @param xp new xp required to levelup
   */
  setXp(
    _seasonId: PromiseOrValue<BigNumberish>,
    _level: PromiseOrValue<BigNumberish>,
    xp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  tokenURI(overrides?: CallOverrides): Promise<string>;

  /**
   * revert if msg.sender tries to undelegate more tokens than they delegated
   * undelegates the tokens from a delegatee
   * @param amount the amount of tokens to undelegate
   * @param delegatee the address who recevied the delegated tokens
   */
  undelegate(
    delegatee: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * returns uri by id
   */
  uri(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  userInfo(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, boolean] & { xp: BigNumber; claimedPremiumPass: boolean }
  >;

  callStatic: {
    CREATOR_TOKEN_ID(overrides?: CallOverrides): Promise<BigNumber>;

    INVALID_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    LOOTBOX_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    PREMIUM_PASS_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    REDEEMABLE_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    SPECIAL_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * only owner can set rewards
     * sets a reward for a seasonId and at level
     * @param _level level at which to change the reward
     * @param _seasonId seasonId for which to change the reward
     * @param id new reward id
     * @param premium true when setting a premium reward
     * @param qty new reward qty
     */
    addReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      qty: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOfBatch(
      owners: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * allows the owner/crafting contract to burn tokens
     * @param amount burn amount
     * @param id burn id
     * @param to burn from address
     */
    burn(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * calculates a pseudorandom index between 0-99
     */
    calculateRandom(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * checks a reward type by id; will revert for 0
     */
    checkType(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * reverts when: user claims a reward for a level at which they are NOT user claims an already claimed reward user claims a premium reward, but is NOT eligible for it when a user has a premium pass and it is their first time claiming a premium reward then burn 1 pass from their balance and set claimedPremiumPass to be true a user can own multiple premium passes just like any other reward it will NOT be burned if the user has already claimed a premium reward
     * claims a reward for a seasonId and at level
     * @param _level level at which to claim the reward
     * @param _seasonId seasonId for which to claim the reward
     * @param premium true when claiming a premium reward
     */
    claimReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    crafting(overrides?: CallOverrides): Promise<string>;

    creatorId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * revert if balance is insufficient
     * delegates msg.sender's tokens to a delegatee
     * @param amount the amount of tokens to delegate
     * @param delegatee the address receiving the delegated tokens
     */
    delegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * tracks who delegates to whom and how much
     */
    delegatedBy(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    delegatedTotal(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets a lootboxOption by lootboxId and index
     */
    getLootboxOptionByIdx(
      id: PromiseOrValue<BigNumberish>,
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<LootboxOptionStructOutput>;

    /**
     * gets a lootboxOptions length by lootboxId
     */
    getLootboxOptionsLength(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * max level is reached when xpToCompleteLevel == 0
     * gets the max level for a seasonId
     */
    getMaxLevel(
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * only owner can give xp
     * gives xp to a user upon completion of quests
     * @param _seasonId seasonId for which to give xp
     * @param user user to give xp to
     * @param xp amount of xp to give
     */
    giveXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isApprovedForAll(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * checks a user claim status on a reward for a seasonId and at level
     * @param _level level at which to check
     * @param _seasonId seasonId for which to check
     * @param premium true when checking for premium rewards
     * @param user user address for which to check
     */
    isRewardClaimed(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTrustedForwarder(
      forwarder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * user is considered premium when:     they own one premium pass or     they have already claimed a premium reward
     * checks if a user has premium pass
     * @param _seasonId seasonId for which to check for premium pass
     * @param user user address
     */
    isUserPremium(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * breaks at the last level, where xpToCompleteLevel is 0
     * gets user level for a seasonId
     * @param _seasonId seasonId for which to get level
     * @param user user address for which to get level
     */
    level(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lootboxId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * allows the owner/crafting contract to mint tokens
     * @param amount mint amount
     * @param id mint id
     * @param to mint to address
     */
    mint(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    newLootbox(
      options: LootboxOptionStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    newSeason(
      levelInfo: LevelInfoStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * upto user to not send a bad id here.
     * opens a lootbox
     * @param id lootboxId to open
     */
    openLootbox(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    seasonId(overrides?: CallOverrides): Promise<BigNumber>;

    seasonInfo(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        xpToCompleteLevel: BigNumber;
        freeRewardId: BigNumber;
        freeRewardQty: BigNumber;
        premiumRewardId: BigNumber;
        premiumRewardQty: BigNumber;
      }
    >;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * only owner can set it
     * sets the crafting proxy address
     * @param _crafting new address
     */
    setCrafting(
      _crafting: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * only owner can set it
     * sets the uri
     * @param _uri new string with the format https://<>/creatorId/id.json
     */
    setURI(
      _uri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * sets required xp to levelup
     * @param _level level at which to change xp
     * @param _seasonId seasonId for which to change xp
     * @param xp new xp required to levelup
     */
    setXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenURI(overrides?: CallOverrides): Promise<string>;

    /**
     * revert if msg.sender tries to undelegate more tokens than they delegated
     * undelegates the tokens from a delegatee
     * @param amount the amount of tokens to undelegate
     * @param delegatee the address who recevied the delegated tokens
     */
    undelegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * returns uri by id
     */
    uri(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { xp: BigNumber; claimedPremiumPass: boolean }
    >;
  };

  filters: {
    "ApprovalForAll(address,address,bool)"(
      owner?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      owner?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    "Delegated(address,address,uint256)"(
      delegator?: PromiseOrValue<string> | null,
      delegatee?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): DelegatedEventFilter;
    Delegated(
      delegator?: PromiseOrValue<string> | null,
      delegatee?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): DelegatedEventFilter;

    "LootboxOpened(uint256,uint256,address)"(
      lootboxId?: PromiseOrValue<BigNumberish> | null,
      idxOpened?: PromiseOrValue<BigNumberish> | null,
      user?: PromiseOrValue<string> | null
    ): LootboxOpenedEventFilter;
    LootboxOpened(
      lootboxId?: PromiseOrValue<BigNumberish> | null,
      idxOpened?: PromiseOrValue<BigNumberish> | null,
      user?: PromiseOrValue<string> | null
    ): LootboxOpenedEventFilter;

    "OwnerUpdated(address,address)"(
      user?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnerUpdatedEventFilter;
    OwnerUpdated(
      user?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnerUpdatedEventFilter;

    "TransferBatch(address,address,address,uint256[],uint256[])"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      amounts?: null
    ): TransferBatchEventFilter;

    "TransferSingle(address,address,address,uint256,uint256)"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      amount?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      amount?: null
    ): TransferSingleEventFilter;

    "URI(string,uint256)"(
      value?: null,
      id?: PromiseOrValue<BigNumberish> | null
    ): URIEventFilter;
    URI(value?: null, id?: PromiseOrValue<BigNumberish> | null): URIEventFilter;

    "Undelegated(address,address,uint256)"(
      delegator?: PromiseOrValue<string> | null,
      delegatee?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): UndelegatedEventFilter;
    Undelegated(
      delegator?: PromiseOrValue<string> | null,
      delegatee?: PromiseOrValue<string> | null,
      amount?: PromiseOrValue<BigNumberish> | null
    ): UndelegatedEventFilter;
  };

  estimateGas: {
    CREATOR_TOKEN_ID(overrides?: CallOverrides): Promise<BigNumber>;

    INVALID_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    LOOTBOX_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    PREMIUM_PASS_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    REDEEMABLE_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    SPECIAL_STARTING_ID(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * only owner can set rewards
     * sets a reward for a seasonId and at level
     * @param _level level at which to change the reward
     * @param _seasonId seasonId for which to change the reward
     * @param id new reward id
     * @param premium true when setting a premium reward
     * @param qty new reward qty
     */
    addReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      qty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOfBatch(
      owners: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * allows the owner/crafting contract to burn tokens
     * @param amount burn amount
     * @param id burn id
     * @param to burn from address
     */
    burn(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * calculates a pseudorandom index between 0-99
     */
    calculateRandom(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * checks a reward type by id; will revert for 0
     */
    checkType(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * reverts when: user claims a reward for a level at which they are NOT user claims an already claimed reward user claims a premium reward, but is NOT eligible for it when a user has a premium pass and it is their first time claiming a premium reward then burn 1 pass from their balance and set claimedPremiumPass to be true a user can own multiple premium passes just like any other reward it will NOT be burned if the user has already claimed a premium reward
     * claims a reward for a seasonId and at level
     * @param _level level at which to claim the reward
     * @param _seasonId seasonId for which to claim the reward
     * @param premium true when claiming a premium reward
     */
    claimReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    crafting(overrides?: CallOverrides): Promise<BigNumber>;

    creatorId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * revert if balance is insufficient
     * delegates msg.sender's tokens to a delegatee
     * @param amount the amount of tokens to delegate
     * @param delegatee the address receiving the delegated tokens
     */
    delegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * tracks who delegates to whom and how much
     */
    delegatedBy(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    delegatedTotal(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets a lootboxOption by lootboxId and index
     */
    getLootboxOptionByIdx(
      id: PromiseOrValue<BigNumberish>,
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets a lootboxOptions length by lootboxId
     */
    getLootboxOptionsLength(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * max level is reached when xpToCompleteLevel == 0
     * gets the max level for a seasonId
     */
    getMaxLevel(
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * only owner can give xp
     * gives xp to a user upon completion of quests
     * @param _seasonId seasonId for which to give xp
     * @param user user to give xp to
     * @param xp amount of xp to give
     */
    giveXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isApprovedForAll(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * checks a user claim status on a reward for a seasonId and at level
     * @param _level level at which to check
     * @param _seasonId seasonId for which to check
     * @param premium true when checking for premium rewards
     * @param user user address for which to check
     */
    isRewardClaimed(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      forwarder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * user is considered premium when:     they own one premium pass or     they have already claimed a premium reward
     * checks if a user has premium pass
     * @param _seasonId seasonId for which to check for premium pass
     * @param user user address
     */
    isUserPremium(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * breaks at the last level, where xpToCompleteLevel is 0
     * gets user level for a seasonId
     * @param _seasonId seasonId for which to get level
     * @param user user address for which to get level
     */
    level(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lootboxId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * allows the owner/crafting contract to mint tokens
     * @param amount mint amount
     * @param id mint id
     * @param to mint to address
     */
    mint(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    newLootbox(
      options: LootboxOptionStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    newSeason(
      levelInfo: LevelInfoStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * upto user to not send a bad id here.
     * opens a lootbox
     * @param id lootboxId to open
     */
    openLootbox(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    seasonId(overrides?: CallOverrides): Promise<BigNumber>;

    seasonInfo(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * only owner can set it
     * sets the crafting proxy address
     * @param _crafting new address
     */
    setCrafting(
      _crafting: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * only owner can set it
     * sets the uri
     * @param _uri new string with the format https://<>/creatorId/id.json
     */
    setURI(
      _uri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * sets required xp to levelup
     * @param _level level at which to change xp
     * @param _seasonId seasonId for which to change xp
     * @param xp new xp required to levelup
     */
    setXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokenURI(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * revert if msg.sender tries to undelegate more tokens than they delegated
     * undelegates the tokens from a delegatee
     * @param amount the amount of tokens to undelegate
     * @param delegatee the address who recevied the delegated tokens
     */
    undelegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * returns uri by id
     */
    uri(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CREATOR_TOKEN_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    INVALID_STARTING_ID(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LOOTBOX_STARTING_ID(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PREMIUM_PASS_STARTING_ID(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    REDEEMABLE_STARTING_ID(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    SPECIAL_STARTING_ID(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * only owner can set rewards
     * sets a reward for a seasonId and at level
     * @param _level level at which to change the reward
     * @param _seasonId seasonId for which to change the reward
     * @param id new reward id
     * @param premium true when setting a premium reward
     * @param qty new reward qty
     */
    addReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      id: PromiseOrValue<BigNumberish>,
      qty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    balanceOf(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceOfBatch(
      owners: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the owner/crafting contract to burn tokens
     * @param amount burn amount
     * @param id burn id
     * @param to burn from address
     */
    burn(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * calculates a pseudorandom index between 0-99
     */
    calculateRandom(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * checks a reward type by id; will revert for 0
     */
    checkType(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * reverts when: user claims a reward for a level at which they are NOT user claims an already claimed reward user claims a premium reward, but is NOT eligible for it when a user has a premium pass and it is their first time claiming a premium reward then burn 1 pass from their balance and set claimedPremiumPass to be true a user can own multiple premium passes just like any other reward it will NOT be burned if the user has already claimed a premium reward
     * claims a reward for a seasonId and at level
     * @param _level level at which to claim the reward
     * @param _seasonId seasonId for which to claim the reward
     * @param premium true when claiming a premium reward
     */
    claimReward(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    crafting(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    creatorId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * revert if balance is insufficient
     * delegates msg.sender's tokens to a delegatee
     * @param amount the amount of tokens to delegate
     * @param delegatee the address receiving the delegated tokens
     */
    delegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * tracks who delegates to whom and how much
     */
    delegatedBy(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    delegatedTotal(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets a lootboxOption by lootboxId and index
     */
    getLootboxOptionByIdx(
      id: PromiseOrValue<BigNumberish>,
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets a lootboxOptions length by lootboxId
     */
    getLootboxOptionsLength(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * max level is reached when xpToCompleteLevel == 0
     * gets the max level for a seasonId
     */
    getMaxLevel(
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * only owner can give xp
     * gives xp to a user upon completion of quests
     * @param _seasonId seasonId for which to give xp
     * @param user user to give xp to
     * @param xp amount of xp to give
     */
    giveXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * checks a user claim status on a reward for a seasonId and at level
     * @param _level level at which to check
     * @param _seasonId seasonId for which to check
     * @param premium true when checking for premium rewards
     * @param user user address for which to check
     */
    isRewardClaimed(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      premium: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      forwarder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * user is considered premium when:     they own one premium pass or     they have already claimed a premium reward
     * checks if a user has premium pass
     * @param _seasonId seasonId for which to check for premium pass
     * @param user user address
     */
    isUserPremium(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * breaks at the last level, where xpToCompleteLevel is 0
     * gets user level for a seasonId
     * @param _seasonId seasonId for which to get level
     * @param user user address for which to get level
     */
    level(
      user: PromiseOrValue<string>,
      _seasonId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lootboxId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * allows the owner/crafting contract to mint tokens
     * @param amount mint amount
     * @param id mint id
     * @param to mint to address
     */
    mint(
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    newLootbox(
      options: LootboxOptionStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    newSeason(
      levelInfo: LevelInfoStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * upto user to not send a bad id here.
     * opens a lootbox
     * @param id lootboxId to open
     */
    openLootbox(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    seasonId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    seasonInfo(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * only owner can set it
     * sets the crafting proxy address
     * @param _crafting new address
     */
    setCrafting(
      _crafting: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * only owner can set it
     * sets the uri
     * @param _uri new string with the format https://<>/creatorId/id.json
     */
    setURI(
      _uri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * sets required xp to levelup
     * @param _level level at which to change xp
     * @param _seasonId seasonId for which to change xp
     * @param xp new xp required to levelup
     */
    setXp(
      _seasonId: PromiseOrValue<BigNumberish>,
      _level: PromiseOrValue<BigNumberish>,
      xp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokenURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * revert if msg.sender tries to undelegate more tokens than they delegated
     * undelegates the tokens from a delegatee
     * @param amount the amount of tokens to undelegate
     * @param delegatee the address who recevied the delegated tokens
     */
    undelegate(
      delegatee: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * returns uri by id
     */
    uri(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userInfo(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
